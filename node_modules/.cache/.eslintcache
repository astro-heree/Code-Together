[{"/Users/amankumar/Code-Together/src/index.js":"1","/Users/amankumar/Code-Together/src/App.jsx":"2","/Users/amankumar/Code-Together/src/pages/Home.jsx":"3","/Users/amankumar/Code-Together/src/pages/EditorPage.jsx":"4","/Users/amankumar/Code-Together/src/Actions.js":"5","/Users/amankumar/Code-Together/src/socket.js":"6","/Users/amankumar/Code-Together/src/components/Client.jsx":"7","/Users/amankumar/Code-Together/src/components/Editor.jsx":"8","/Users/amankumar/Code-Together/src/components/CodeRun.jsx":"9","/Users/amankumar/Code-Together/src/contexts/LiveKitContext.jsx":"10","/Users/amankumar/Code-Together/src/components/MediaControls.jsx":"11"},{"size":211,"mtime":1749137026861,"results":"12","hashOfConfig":"13"},{"size":855,"mtime":1749142253265,"results":"14","hashOfConfig":"13"},{"size":2231,"mtime":1749138899070,"results":"15","hashOfConfig":"13"},{"size":6477,"mtime":1750146056159,"results":"16","hashOfConfig":"13"},{"size":200,"mtime":1749141962382,"results":"17","hashOfConfig":"13"},{"size":402,"mtime":1750145802156,"results":"18","hashOfConfig":"13"},{"size":5107,"mtime":1749149246472,"results":"19","hashOfConfig":"13"},{"size":1914,"mtime":1749141647999,"results":"20","hashOfConfig":"13"},{"size":2967,"mtime":1749141962383,"results":"21","hashOfConfig":"13"},{"size":12471,"mtime":1750146020118,"results":"22","hashOfConfig":"13"},{"size":724,"mtime":1749142191823,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","suppressedMessages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},"ax8kgz",{"filePath":"28","messages":"29","suppressedMessages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"31","messages":"32","suppressedMessages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37"},{"filePath":"38","messages":"39","suppressedMessages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"41","messages":"42","suppressedMessages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"44","messages":"45","suppressedMessages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"47","messages":"48","suppressedMessages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"27"},{"filePath":"51","messages":"52","suppressedMessages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"54","messages":"55","suppressedMessages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"27"},{"filePath":"58","messages":"59","suppressedMessages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},"/Users/amankumar/Code-Together/src/index.js",[],[],[],"/Users/amankumar/Code-Together/src/App.jsx",[],[],"/Users/amankumar/Code-Together/src/pages/Home.jsx",[],[],"/Users/amankumar/Code-Together/src/pages/EditorPage.jsx",["61","62"],[],"import React, { useEffect, useRef, useState } from 'react';\nimport Client from '../components/Client';\nimport Editor from '../components/Editor';\nimport MediaControls from '../components/MediaControls';\nimport { initSocket } from '../socket';\nimport ACTIONS from '../Actions';\nimport { Navigate, useLocation, useNavigate, useParams } from 'react-router-dom';\nimport toast from 'react-hot-toast';\nimport CodeRun from '../components/CodeRun';\nimport { useLiveKit } from '../contexts/LiveKitContext';\n\nconst EditorPage = () => {\n  const codeRef = useRef(null);\n  const socketRef = useRef(null);\n  const location = useLocation();\n  const { roomId } = useParams();\n  const reactNavigator = useNavigate();\n\n  const [clients, setClients] = useState([]);\n  \n  const {\n    connectToRoom,\n    disconnectFromRoom,\n    toggleMic,\n    toggleVideo,\n    isMicOn,\n    isVideoOn,\n    localVideoTrack,\n    localAudioTrack,\n    getParticipantVideoTrack,\n    getParticipantAudioTrack,\n    isParticipantVideoEnabled,\n    isParticipantAudioEnabled,\n    isConnected: isLiveKitConnected\n  } = useLiveKit();\n\n  const connectToLiveKit = async () => {\n    try {\n      const backendUrl = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8080';\n      const response = await fetch(`${backendUrl}/api/get-token`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          roomName: roomId,\n          participantName: location.state?.username,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to get LiveKit token');\n      }\n\n      const { token, wsUrl } = await response.json();\n      await connectToRoom(token, wsUrl, roomId, location.state?.username);\n      toast.success('Connected to voice/video');\n    } catch (error) {\n      console.error('Failed to connect to LiveKit:', error);\n      toast.error('Failed to connect to voice/video');\n    }\n  };\n\n  useEffect(() => {\n    const init = async () => {\n      try {\n        socketRef.current = await initSocket();\n\n        socketRef.current.on('connect_error', (err) => handleErrors(err));\n        socketRef.current.on('connect_failed', (err) => handleErrors(err));\n\n        function handleErrors(e) {\n          console.error('Socket connection error:', e);\n          toast.error('Socket connection failed, try again later.');\n          reactNavigator('/');\n        }\n\n        socketRef.current.on('connect', () => {\n          socketRef.current.emit(ACTIONS.JOIN, {\n            roomId,\n            username: location.state?.username,\n          });\n        });\n\n        if (socketRef.current.connected) {\n          socketRef.current.emit(ACTIONS.JOIN, {\n            roomId,\n            username: location.state?.username,\n          });\n        }\n\n        socketRef.current.on(ACTIONS.JOINED, ({ clients, username, socketId }) => {\n          if (username !== location.state?.username) {\n            toast.success(`${username} joined the room.`);\n          }\n          setClients(clients);\n          \n          if (codeRef.current && socketRef.current.connected) {\n            socketRef.current.emit(ACTIONS.SYNC_CODE, {\n              code: codeRef.current,\n              socketId\n            });\n          }\n        });\n\n        socketRef.current.on(ACTIONS.DISCONNECTED, ({ socketId, username }) => {\n          toast.success(`${username} left the room.`);\n          setClients((prev) => {\n            return prev.filter((client) => client.socketId !== socketId);\n          });\n        });\n\n        await connectToLiveKit();\n\n      } catch (error) {\n        console.error('Failed to initialize:', error);\n        toast.error('Failed to connect to server');\n        reactNavigator('/');\n      }\n    };\n\n    init();\n    \n    return () => {\n      if (socketRef.current) {\n        socketRef.current.disconnect();\n        socketRef.current.off(ACTIONS.JOINED);\n        socketRef.current.off(ACTIONS.DISCONNECTED);\n        socketRef.current.off('connect');\n        socketRef.current.off('connect_error');\n        socketRef.current.off('connect_failed');\n      }\n      disconnectFromRoom();\n    };\n\n  }, []);\n\n  async function copyRoomId() {\n    try {\n      await navigator.clipboard.writeText(roomId);\n      toast.success(\"Room ID has been copied!\");\n    } catch (err) {\n      toast.error(\"Could not copy the Room ID\");\n    }\n  }\n\n  function leaveRoom() {\n    disconnectFromRoom();\n    reactNavigator('/');\n  }\n\n  if (!location.state) {\n    return <Navigate to=\"/\"/>\n  }\n\n  return (\n    <div className=\"mainWrap\">\n      <div className=\"aside\">\n        <div className=\"asideInner\">\n          <div className=\"logo\">\n            <img src=\"/code-sync.png\" alt=\"logo\" className=\"logoImage\" />\n          </div>\n          <h3>Connected</h3>\n          <div className=\"clientsList\">\n            {clients.map((client) => {\n              const isLocalUser = client.username === location.state?.username;\n              const videoTrack = isLocalUser ? localVideoTrack : getParticipantVideoTrack(client.username);\n              const audioTrack = isLocalUser ? localAudioTrack : getParticipantAudioTrack(client.username);\n              const isVideoEnabled = isLocalUser ? isVideoOn : isParticipantVideoEnabled(client.username);\n              const isAudioEnabled = isLocalUser ? isMicOn : isParticipantAudioEnabled(client.username);\n              \n              return (\n                <Client \n                  key={client.socketId}\n                  username={client.username}\n                  videoTrack={videoTrack}\n                  audioTrack={audioTrack}\n                  isVideoEnabled={isVideoEnabled}\n                  isAudioEnabled={isAudioEnabled}\n                />\n              );\n            })}\n          </div>\n          <MediaControls\n            isMicOn={isMicOn}\n            isVideoOn={isVideoOn}\n            onToggleMic={toggleMic}\n            onToggleVideo={toggleVideo}\n          />\n          <button className=\"btn copyBtn\" onClick={copyRoomId}>\n            Copy Room ID\n          </button>\n          <button className=\"btn leaveBtn\" onClick={leaveRoom}>\n            Leave\n          </button>\n        </div>\n      </div>\n      <div className=\"editorWrap\">\n        <Editor\n          socketRef={socketRef}\n          roomId={roomId}\n          onCodeChange={(code) => {\n            codeRef.current = code;\n          }}\n        />\n      </div>\n      <CodeRun code={codeRef.current} />\n    </div>\n  );\n};\n\nexport default EditorPage;","/Users/amankumar/Code-Together/src/Actions.js",[],[],"/Users/amankumar/Code-Together/src/socket.js",[],[],"/Users/amankumar/Code-Together/src/components/Client.jsx",[],[],"/Users/amankumar/Code-Together/src/components/Editor.jsx",["63","64","65"],[],"import React, { useEffect } from 'react';\nimport codemirror from 'codemirror';\nimport 'codemirror/mode/javascript/javascript';\nimport 'codemirror/theme/dracula.css';\nimport 'codemirror/addon/edit/closetag';\nimport 'codemirror/addon/edit/closebrackets';\nimport 'codemirror/lib/codemirror.css'\nimport { useRef } from 'react';\nimport ACTIONS from '../Actions';\n\nconst Editor = ({ socketRef, roomId, onCodeChange }) => {\n  const editorRef = useRef(null);\n\n  useEffect(() => {\n    const init = async () => {\n      editorRef.current = codemirror.fromTextArea(\n        document.getElementById(\"realtimeEditor\"),\n        {\n          mode: { name: \"javascript\", json: true },\n          theme: \"dracula\",\n          autoCloseTags: true,\n          autoCloseBrackets: true,\n          lineNumbers: true,\n        }\n      );\n\n      editorRef.current.on(\"change\", (instance, changes) => {\n        const { origin } = changes;\n        const code = instance.getValue();\n        onCodeChange(code);\n\n        if (origin !== \"setValue\" && socketRef.current && socketRef.current.connected) {\n          socketRef.current.emit(ACTIONS.CODE_CHANGE, {\n            roomId,\n            code,\n          });\n        }\n      });\n    };\n\n    init();\n  }, []);\n\n  useEffect(() => {\n    if (socketRef.current && editorRef.current) {\n      const handleCodeChange = ({ code }) => {\n        if (code !== null && editorRef.current) {\n          const currentCode = editorRef.current.getValue();\n          if (currentCode !== code) {\n            editorRef.current.setValue(code);\n          }\n        }\n      };\n\n      socketRef.current.on(ACTIONS.CODE_CHANGE, handleCodeChange);\n\n      return () => {\n        if (socketRef.current) {\n          socketRef.current.off(ACTIONS.CODE_CHANGE, handleCodeChange);\n        }\n      };\n    }\n  }, [socketRef.current, editorRef.current]);\n\n  return <textarea id=\"realtimeEditor\"></textarea>;\n};\n\nexport default Editor;","/Users/amankumar/Code-Together/src/components/CodeRun.jsx",[],[],"/Users/amankumar/Code-Together/src/contexts/LiveKitContext.jsx",["66"],[],"import React, { createContext, useContext, useState, useEffect, useRef } from 'react';\nimport { Room, RoomEvent, Track } from 'livekit-client';\n\nconst LiveKitContext = createContext();\n\nexport const useLiveKit = () => {\n  const context = useContext(LiveKitContext);\n  if (!context) {\n    throw new Error('useLiveKit must be used within a LiveKitProvider');\n  }\n  return context;\n};\n\nexport const LiveKitProvider = ({ children }) => {\n  const [room, setRoom] = useState(null);\n  const [participants, setParticipants] = useState(new Map());\n  const [isConnected, setIsConnected] = useState(false);\n  const [isMicOn, setIsMicOn] = useState(false);\n  const [isVideoOn, setIsVideoOn] = useState(false);\n  const [localVideoTrack, setLocalVideoTrack] = useState(null);\n  const [localAudioTrack, setLocalAudioTrack] = useState(null);\n  const [audioContextEnabled, setAudioContextEnabled] = useState(false);\n  \n  const roomRef = useRef(null);\n\n  // Function to enable audio context\n  const enableAudioContext = async () => {\n    try {\n      if (typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext)) {\n        const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        if (audioContext.state === 'suspended') {\n          await audioContext.resume();\n        }\n        setAudioContextEnabled(true);\n      }\n    } catch (error) {\n      console.error('Failed to enable audio context:', error);\n    }\n  };\n\n  const connectToRoom = async (token, wsUrl, roomName, participantName) => {\n    try {\n      const newRoom = new Room();\n      roomRef.current = newRoom;\n      \n      newRoom.on(RoomEvent.ParticipantConnected, (participant) => {\n        setParticipants(prev => {\n          const newMap = new Map(prev);\n          newMap.set(participant.identity, participant);\n          return newMap;\n        });\n      });\n\n      newRoom.on(RoomEvent.ParticipantDisconnected, (participant) => {\n        setParticipants(prev => {\n          const newMap = new Map(prev);\n          newMap.delete(participant.identity);\n          return newMap;\n        });\n      });\n\n      newRoom.on(RoomEvent.TrackSubscribed, (track, publication, participant) => {\n        if (track.kind === Track.Kind.Audio) {\n          if (publication.setEnabled) {\n            publication.setEnabled(true);\n          }\n        }\n        \n        if (track.kind === Track.Kind.Video) {\n          if (publication.setEnabled) {\n            publication.setEnabled(true);\n          }\n        }\n        \n        setParticipants(prev => {\n          const newMap = new Map(prev);\n          newMap.set(participant.identity, participant);\n          return newMap;\n        });\n      });\n\n      newRoom.on(RoomEvent.TrackUnsubscribed, (track, publication, participant) => {\n        setParticipants(prev => {\n          const newMap = new Map(prev);\n          newMap.set(participant.identity, participant);\n          return newMap;\n        });\n      });\n\n      newRoom.on(RoomEvent.TrackPublished, (publication, participant) => {\n        if (publication && publication.setSubscribed) {\n          publication.setSubscribed(true);\n        }\n        \n        setParticipants(prev => {\n          const newMap = new Map(prev);\n          newMap.set(participant.identity, participant);\n          return newMap;\n        });\n      });\n\n      newRoom.on(RoomEvent.TrackUnpublished, (publication, participant) => {\n        // Track unpublished - no action needed\n      });\n\n      await newRoom.connect(wsUrl, token, {\n        autoSubscribe: true,\n        audio: true,\n        video: true\n      });\n      setRoom(newRoom);\n      setIsConnected(true);\n\n      if (newRoom.localParticipant) {\n        setParticipants(prev => {\n          const newMap = new Map(prev);\n          newMap.set(newRoom.localParticipant.identity, newRoom.localParticipant);\n          return newMap;\n        });\n      }\n\n      if (newRoom.participants && typeof newRoom.participants.forEach === 'function') {\n        newRoom.participants.forEach((participant) => {\n          setParticipants(prev => {\n            const newMap = new Map(prev);\n            newMap.set(participant.identity, participant);\n            return newMap;\n          });\n          \n          if (participant.trackPublications) {\n            participant.trackPublications.forEach((publication) => {\n              if (publication && publication.setSubscribed) {\n                publication.setSubscribed(true);\n              }\n            });\n          }\n        });\n      } else if (newRoom.participants && newRoom.participants.size > 0) {\n        for (const [identity, participant] of newRoom.participants) {\n          setParticipants(prev => {\n            const newMap = new Map(prev);\n            newMap.set(participant.identity, participant);\n            return newMap;\n          });\n          \n          if (participant.trackPublications) {\n            participant.trackPublications.forEach((publication) => {\n              if (publication && publication.setSubscribed) {\n                publication.setSubscribed(true);\n              }\n            });\n          }\n        }\n      }\n\n    } catch (error) {\n      console.error('Failed to connect to LiveKit room:', error);\n      throw error;\n    }\n  };\n\n  const disconnectFromRoom = () => {\n    if (roomRef.current) {\n      roomRef.current.disconnect();\n      setRoom(null);\n      setIsConnected(false);\n      setParticipants(new Map());\n      setLocalVideoTrack(null);\n      setLocalAudioTrack(null);\n      setIsMicOn(false);\n      setIsVideoOn(false);\n      setAudioContextEnabled(false);\n    }\n  };\n\n  const toggleMic = async () => {\n    if (!room) return;\n\n    try {\n      // First, ensure audio context is enabled when turning on mic\n      if (!isMicOn && !audioContextEnabled) {\n        await enableAudioContext();\n      }\n\n      if (isMicOn) {\n        // Turn off mic\n        await room.localParticipant.setMicrophoneEnabled(false);\n        setIsMicOn(false);\n        setLocalAudioTrack(null);\n      } else {\n        // Turn on mic\n        await room.localParticipant.setMicrophoneEnabled(true);\n        setIsMicOn(true);\n        \n        let audioPublication = room.localParticipant.getTrackPublication('microphone');\n        if (!audioPublication) {\n          audioPublication = room.localParticipant.getTrackPublication('mic');\n        }\n        if (!audioPublication) {\n          const audioTracks = Array.from(room.localParticipant.trackPublications.values())\n            .filter(pub => pub.kind === Track.Kind.Audio);\n          if (audioTracks.length > 0) {\n            audioPublication = audioTracks[0];\n          }\n        }\n        \n        if (audioPublication && audioPublication.track) {\n          setLocalAudioTrack(audioPublication.track);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to toggle microphone:', error);\n    }\n  };\n\n  const toggleVideo = async () => {\n    if (!room) return;\n\n    try {\n      if (isVideoOn) {\n        // Turn off video\n        await room.localParticipant.setCameraEnabled(false);\n        setIsVideoOn(false);\n        setLocalVideoTrack(null);\n      } else {\n        // Turn on video\n        await room.localParticipant.setCameraEnabled(true);\n        setIsVideoOn(true);\n        \n        // Wait a moment for the track to be available\n        setTimeout(() => {\n          // Get the local video track using correct API\n          // Try different source names\n          let videoPublication = room.localParticipant.getTrackPublication('camera');\n          if (!videoPublication) {\n            videoPublication = room.localParticipant.getTrackPublication('webcam');\n          }\n          if (!videoPublication) {\n            // Get the first video track\n            const videoTracks = Array.from(room.localParticipant.trackPublications.values())\n              .filter(pub => pub.kind === Track.Kind.Video);\n            if (videoTracks.length > 0) {\n              videoPublication = videoTracks[0];\n            }\n          }\n          \n          if (videoPublication && videoPublication.track) {\n            setLocalVideoTrack(videoPublication.track);\n          }\n        }, 100);\n      }\n    } catch (error) {\n      console.error('Error toggling camera:', error);\n    }\n  };\n\n  const getParticipantVideoTrack = (participantIdentity) => {\n    const participant = participants.get(participantIdentity);\n    if (!participant || !participant.getTrackPublication) return null;\n    \n    try {\n      // Try different source names for video\n      let videoPublication = participant.getTrackPublication('camera');\n      if (!videoPublication) {\n        videoPublication = participant.getTrackPublication('webcam');\n      }\n      if (!videoPublication) {\n        // Get the first video track\n        const videoTracks = Array.from(participant.trackPublications.values())\n          .filter(pub => pub.kind === Track.Kind.Video);\n        if (videoTracks.length > 0) {\n          videoPublication = videoTracks[0];\n        }\n      }\n      return videoPublication?.track || null;\n    } catch (error) {\n      console.error('Error getting participant video track:', error);\n      return null;\n    }\n  };\n\n  const getParticipantAudioTrack = (participantIdentity) => {\n    const participant = participants.get(participantIdentity);\n    if (!participant || !participant.getTrackPublication) {\n      return null;\n    }\n    \n    try {\n      // Try different source names for audio\n      let audioPublication = participant.getTrackPublication('microphone');\n      if (!audioPublication) {\n        audioPublication = participant.getTrackPublication('mic');\n      }\n      if (!audioPublication) {\n        // Get the first audio track\n        const audioTracks = Array.from(participant.trackPublications.values())\n          .filter(pub => pub.kind === Track.Kind.Audio);\n        if (audioTracks.length > 0) {\n          audioPublication = audioTracks[0];\n        }\n      }\n      \n      return audioPublication?.track || null;\n    } catch (error) {\n      console.error('Error getting participant audio track:', error);\n      return null;\n    }\n  };\n\n  const isParticipantVideoEnabled = (participantIdentity) => {\n    const participant = participants.get(participantIdentity);\n    if (!participant || !participant.getTrackPublication) return false;\n    \n    try {\n      // Try different source names for video\n      let videoPublication = participant.getTrackPublication('camera');\n      if (!videoPublication) {\n        videoPublication = participant.getTrackPublication('webcam');\n      }\n      if (!videoPublication) {\n        // Get the first video track\n        const videoTracks = Array.from(participant.trackPublications.values())\n          .filter(pub => pub.kind === Track.Kind.Video);\n        if (videoTracks.length > 0) {\n          videoPublication = videoTracks[0];\n        }\n      }\n      return videoPublication?.isEnabled || false;\n    } catch (error) {\n      console.error('Error checking participant video status:', error);\n      return false;\n    }\n  };\n\n  const isParticipantAudioEnabled = (participantIdentity) => {\n    const participant = participants.get(participantIdentity);\n    if (!participant || !participant.getTrackPublication) return false;\n    \n    try {\n      // Try different source names for audio\n      let audioPublication = participant.getTrackPublication('microphone');\n      if (!audioPublication) {\n        audioPublication = participant.getTrackPublication('mic');\n      }\n      if (!audioPublication) {\n        // Get the first audio track\n        const audioTracks = Array.from(participant.trackPublications.values())\n          .filter(pub => pub.kind === Track.Kind.Audio);\n        if (audioTracks.length > 0) {\n          audioPublication = audioTracks[0];\n        }\n      }\n      return audioPublication?.isEnabled || false;\n    } catch (error) {\n      console.error('Error checking participant audio status:', error);\n      return false;\n    }\n  };\n\n  useEffect(() => {\n    return () => {\n      disconnectFromRoom();\n    };\n  }, []);\n\n  const value = {\n    room,\n    participants,\n    isConnected,\n    isMicOn,\n    isVideoOn,\n    localVideoTrack,\n    localAudioTrack,\n    connectToRoom,\n    disconnectFromRoom,\n    toggleMic,\n    toggleVideo,\n    getParticipantVideoTrack,\n    getParticipantAudioTrack,\n    isParticipantVideoEnabled,\n    isParticipantAudioEnabled,\n    audioContextEnabled\n  };\n\n  return (\n    <LiveKitContext.Provider value={value}>\n      {children}\n    </LiveKitContext.Provider>\n  );\n}; ","/Users/amankumar/Code-Together/src/components/MediaControls.jsx",[],[],{"ruleId":"67","severity":1,"message":"68","line":34,"column":18,"nodeType":"69","messageId":"70","endLine":34,"endColumn":36},{"ruleId":"71","severity":1,"message":"72","line":136,"column":6,"nodeType":"73","endLine":136,"endColumn":8,"suggestions":"74"},{"ruleId":"71","severity":1,"message":"75","line":42,"column":6,"nodeType":"73","endLine":42,"endColumn":8,"suggestions":"76"},{"ruleId":"71","severity":1,"message":"77","line":59,"column":21,"nodeType":"69","endLine":59,"endColumn":28},{"ruleId":"71","severity":1,"message":"78","line":63,"column":6,"nodeType":"73","endLine":63,"endColumn":44,"suggestions":"79"},{"ruleId":"67","severity":1,"message":"80","line":139,"column":21,"nodeType":"69","messageId":"70","endLine":139,"endColumn":29},"no-unused-vars","'isLiveKitConnected' is assigned a value but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'connectToLiveKit', 'disconnectFromRoom', 'location.state?.username', 'reactNavigator', and 'roomId'. Either include them or remove the dependency array.","ArrayExpression",["81"],"React Hook useEffect has missing dependencies: 'onCodeChange', 'roomId', and 'socketRef'. Either include them or remove the dependency array. If 'onCodeChange' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["82"],"The ref value 'socketRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'socketRef.current' to a variable inside the effect, and use that variable in the cleanup function.","React Hook useEffect has a missing dependency: 'socketRef'. Either include it or remove the dependency array. Mutable values like 'socketRef.current' aren't valid dependencies because mutating them doesn't re-render the component.",["83"],"'identity' is assigned a value but never used.",{"desc":"84","fix":"85"},{"desc":"86","fix":"87"},{"desc":"88","fix":"89"},"Update the dependencies array to be: [connectToLiveKit, disconnectFromRoom, location.state?.username, reactNavigator, roomId]",{"range":"90","text":"91"},"Update the dependencies array to be: [onCodeChange, roomId, socketRef]",{"range":"92","text":"93"},"Update the dependencies array to be: [socketRef]",{"range":"94","text":"95"},[4136,4138],"[connectToLiveKit, disconnectFromRoom, location.state?.username, reactNavigator, roomId]",[1221,1223],"[onCodeChange, roomId, socketRef]",[1794,1832],"[socketRef]"]